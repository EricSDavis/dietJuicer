#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pandas as pd
import glob

##### Load config file #####

configfile: "config/config.yaml"

onsuccess:
	print("alignFASTQ completed successfully!")

##### Define rules #####
rule all:
	input:
		expand('output/{prefix}_inter{ext}', prefix=config["prefix"], ext=['.txt', '_hists.m', '.hic', '_30.txt', '_30_hists.m', '_30.hic'])

rule countLigations:
	input:
		R1 = lambda wildcards: ['output/splitsR1/{sample}_R1.fastq.gz'.format(sample=wildcards.sample)],
		R2 = lambda wildcards: ['output/splitsR2/{sample}_R2.fastq.gz'.format(sample=wildcards.sample)]
	output:
		temp = temp('output/{prefix}_countLigations_split{sample}_temp'), ## Make temporary
		res = temp('output/{prefix}_countLigations_split{sample}_norm.txt.res.txt'),
		linecount = temp('output/{prefix}_countLigations_split{sample}_linecount.txt')
	log:
		err = "output/logs/{prefix}_countLigations_split{sample}.err",
		out = "output/logs/{prefix}_countLigations_split{sample}.out"
	params:
		ligation = config['ligation']
	threads: 1
	benchmark: 
		'output/benchmarks/{prefix}_countLigations_split{sample}.tsv'
	shell:
		"R1={input.R1} R2={input.R2} ligation={params.ligation} temp={output.temp} res={output.res} linecount={output.linecount} sh scripts/countLigations.sh 2> {log.err} 1> {log.out}"

rule align:
	input:
		R1 = lambda wildcards: ['output/splitsR1/{sample}_R1.fastq.gz'.format(sample=wildcards.sample)],
		R2 = lambda wildcards: ['output/splitsR2/{sample}_R2.fastq.gz'.format(sample=wildcards.sample)]
	output:
		sam = temp("output/{prefix}_align_split{sample}.sam") ## Make temporary
	log:
		err = "output/logs/{prefix}_align_split{sample}.err"
	threads: 8
	params:
		fasta = config['fasta']
	benchmark: 
		"output/benchmarks/{prefix}_align_split{sample}.tsv"
	shell:
		"module load bwa; "
		"bwa mem -SP5M -t {threads} {params.fasta} {input.R1} {input.R2} > {output.sam} 2> {log.err}"

rule chimera:
	input:
		sam = rules.align.output.sam
	output:
		norm = temp("output/{prefix}_align_split{sample}_norm.txt"),
		normRes = temp("output/{prefix}_align_split{sample}_norm.txt.res.txt"),
		alignable = temp("output/{prefix}_align_split{sample}_alignable.sam"), ## Make temporary
		collisions = temp("output/{prefix}_align_split{sample}_collisions.sam"), ## Make temporary
		lowqcollisions = temp("output/{prefix}_align_split{sample}_collisions_low_mapq.sam"), ## Make temporary
		unmapped = temp("output/{prefix}_align_split{sample}_unmapped.sam"), ## Make temporary
		mapq0 = temp("output/{prefix}_align_split{sample}_mapq0.sam"), ## Make temporary
		unpaired = temp("output/{prefix}_align_split{sample}_unpaired.sam") ## Make temporary
	log:
		err = "output/logs/{prefix}_chimera_split{sample}.err",
		out = "output/logs/{prefix}_chimera_split{sample}.out"
	threads: 1
	params:
		fname = 'output/{prefix}_align_split{sample}',
		mapq0_reads_included = config['mapq0_reads_included']
	benchmark: 
		'output/benchmarks/{prefix}_chimera_split{sample}.tsv'
	run:
		shell('touch {output}')
		shell('gawk -v "fname"={params.fname} -v "mapq0_reads_included"={params.mapq0_reads_included} -f ./scripts/chimeric_blacklist.awk {input.sam} 2> {log.err} 1> {log.out}')

rule fragment:
	input:
		norm = rules.chimera.output.norm
	output:
		frag = temp("output/{prefix}_fragment_split{sample}.frag.txt")
	log:
		err = "output/logs/{prefix}_fragment_split{sample}.err"
	threads: 1
	params:
		site = config['site'],
		site_file = config['site_file']
	benchmark:
		'output/benchmarks/{prefix}_fragment_split{sample}.tsv'
	shell: ## Use better error handling with the if/else statement for restriction site
		"""
		if [ {params.site} != "none" ]
		then
				./scripts/fragment.pl {input.norm} {output.frag} {params.site_file} 2> {log.err}    
		else
				awk '{{printf("%s %s %s %d %s %s %s %d", $1, $2, $3, 0, $4, $5, $6, 1); for (i=7; i<=NF; i++) {{printf(" %s",$i);}}printf("\n");}}' {input.norm} > {output.frag} 2> {log.err}
		fi
		"""

rule sort:
	input:
		rules.fragment.output.frag
	output:
		sorted = temp("output/{prefix}_sort_split{sample}.sort.txt")
	log:
		err = "output/logs/{prefix}_sort_split{sample}.err"
	threads: 8
	shadow: "minimal"
	benchmark:
		'output/benchmarks/{prefix}_sort_split{sample}.tsv'
	shell:
		"""
		tmp_dir=$(mktemp -d -p $PWD)
		sort --parallel={threads} -T $tmp_dir -k2,2d -k6,6d -k4,4n -k8,8n -k1,1n -k5,5n -k3,3n {input} > {output.sorted} 2> {log.err}
		rm -rf $tmp_dir
		"""

rule mergedSort:
	input:
		expand('output/{prefix}_sort_split{sample}.sort.txt', prefix=config["prefix"], sample=glob_wildcards('output/splitsR1/{sample}_R1.fastq.gz').sample)
	output:
		temp('output/{prefix}_mergedSort_merged_sort.txt')
	log:
		err = 'output/logs/{prefix}_mergedSort.err'
	threads: 8
	shadow: "minimal"
	benchmark:
		'output/benchmarks/{prefix}_mergedSort.tsv'
	shell:
		"""
		tmp_dir=$(mktemp -d -p $PWD)
		sort --parallel={threads} -T $tmp_dir -m -k2,2d -k6,6d -k4,4n -k8,8n -k1,1n -k5,5n -k3,3n {input} > {output} 2> {log.err}
		rm -rf $tmp_dir
		"""

rule dedup:
	input:
		rules.mergedSort.output
	output:
		dups = temp("output/{prefix}_dedup_dups.txt"),
		merged_nodups = "output/{prefix}_dedup_merged_nodups.txt",
		optdups = temp("output/{prefix}_dedup_opt_dups.txt")
	log:
		err = 'output/logs/{prefix}_dedup.err'
	params:
		name = 'output/{prefix}_'
	threads: 1
	benchmark:
		'output/benchmarks/{prefix}_dedup.tsv'
	run:
		shell('touch {output}'),
		shell('awk -f ./scripts/dups.awk -v name={params.name} {input} 2> {log.err}')

def interInput(wildcards):
	sample=glob_wildcards('output/splitsR1/{sample}_R1.fastq.gz').sample
	combined=[]
	for i in sample:
		combined.append('output/{prefix}_countLigations_split{sample}_norm.txt.res.txt'.format(prefix=config['prefix'], sample=i))
		combined.append('output/{prefix}_align_split{sample}_norm.txt.res.txt'.format(prefix=config['prefix'], sample=i))
	return combined

rule inter:
	input:
		res = interInput,
		dups = rules.dedup.output.dups,
		optdups = rules.dedup.output.optdups,
		merged_nodups = rules.dedup.output.merged_nodups
	output:
		inter = 'output/{prefix}_inter.txt',
		hists = 'output/{prefix}_inter_hists.m'
	log:
		err = 'output/logs/{prefix}_inter.err'
	params:
		ligation = config['ligation'],
		site_file = config['site_file']
	threads: 1
	benchmark:
		'output/benchmarks/{prefix}_inter.tsv'
	shell:
		"""
		cat {input.res} | awk -f ./scripts/stats_sub.awk > {output.inter} 2> {log.err}
		./scripts/juicer_tools LibraryComplexity $(wc -l < {input.merged_nodups}) $(wc -l < {input.dups}) $(wc -l < {input.optdups}) >> {output.inter} 2>> {log.err}
		./scripts/statistics.pl -s {params.site_file} -l {params.ligation} -o {output.inter} -q 1 {input.merged_nodups} 2>> {log.err}
		"""

rule inter30:
	input:
		res = interInput,
		dups = rules.dedup.output.dups,
		optdups = rules.dedup.output.optdups,
		merged_nodups = rules.dedup.output.merged_nodups
	output:
		inter30 = 'output/{prefix}_inter_30.txt',
		hists30 = 'output/{prefix}_inter_30_hists.m'
	log:
		err = 'output/logs/{prefix}_inter30.err'
	params:
		ligation = config['ligation'],
		site_file = config['site_file']
	threads: 1
	benchmark:
		'output/benchmarks/{prefix}_inter30.tsv'
	shell:
		"""
		cat {input.res} | awk -f ./scripts/stats_sub.awk > {output.inter30} 2>> {log.err}
		./scripts/juicer_tools LibraryComplexity $(wc -l < {input.merged_nodups}) $(wc -l < {input.dups}) $(wc -l < {input.optdups}) >> {output.inter30} 2>> {log.err}
		./scripts/statistics.pl -s {params.site_file} -l {params.ligation} -o {output.inter30} -q 30 {input.merged_nodups} 2>> {log.err}
		"""

rule hic:
	input:
		inter = rules.inter.output.inter,
		hists = rules.inter.output.hists,
		merged_nodups = rules.dedup.output.merged_nodups
	output:
		hic = 'output/{prefix}_inter.hic'
	log:
		err = 'output/logs/{prefix}_hic.err',
		out = 'output/logs/{prefix}_hic.out'
	params:
		chromSizes = config['chromSizes']
	threads: 1
	benchmark:
		'output/benchmarks/{prefix}_hic.tsv'
	shell:
		"""
		./scripts/juicer_tools pre -s {input.inter} -g {input.hists} -q 1 {input.merged_nodups} {output.hic} {params.chromSizes} 1> {log.out} 2> {log.err}
		"""

rule hic30:
	input:
		inter30 = rules.inter30.output.inter30,
		hists30 = rules.inter30.output.hists30,
		merged_nodups = rules.dedup.output.merged_nodups
	output:
		hic30 = 'output/{prefix}_inter_30.hic'
	log:
		err = 'output/logs/{prefix}_hic30.err',
		out = 'output/logs/{prefix}_hic30.out'
	params:
		chromSizes = config['chromSizes']
	threads: 1
	benchmark:
		'output/benchmarks/{prefix}_hic30.tsv'
	shell:
		"""
		./scripts/juicer_tools pre -s {input.inter30} -g {input.hists30} -q 1 {input.merged_nodups} {output.hic30} {params.chromSizes} 1> {log.out} 2> {log.err}
		"""